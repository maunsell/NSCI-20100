classdef MetricsStimulus < handle
  % Contrast threshold stimuli controller
  properties
    currentOffsetPix
    tag
  end
  properties (Constant)
    marginPix = 10;
    pixelDepth = 32;
  end
  properties (GetAccess = private)
    blankImage
    currentImageIndex
    currentOffsetIndex
    doStimDisplay
    dotImage
    frameDurS
    grayColor
    hAxes                     % axes for drawing/erasing dots
    hFig
    images
    imagePosPix               % locations for putting the images in the window
    numPos
    pixPerMM
    screenNumber
    spotRadiusPix
    stepSizeDeg
    stepSizePix
    topPriorityLevel
    viewDistanceMM
    whiteColor
    window
    windRectPix
    xCenterPix
    yCenterPix
  end
  methods (Static)
  end
  methods
    function obj = MetricsStimulus(app, doStimDisplay, stepSizeDeg)
      obj.doStimDisplay = doStimDisplay;
      obj.currentOffsetPix = 0;
      if obj.doStimDisplay
        imtool close all;                               % close imtool figures from Image Processing Toolbox
        obj.spotRadiusPix = 10;
        obj.stepSizeDeg = stepSizeDeg;
        obj.currentImageIndex = 1;
        dockPix = 75;
        windHeightPix = 60;
        screenRectPix = get(0, 'MonitorPositions');   	% get the size of the primary screen
        windWidthPix = screenRectPix(3) - 2 * obj.marginPix;
        obj.windRectPix = [obj.marginPix, obj.marginPix + dockPix, windWidthPix, windHeightPix];
%         [widthMM, ~] = Screen('DisplaySize', obj.screenNumber);
        obj.hFig = figure('Renderer', 'painters', 'Position', [obj.marginPix, obj.marginPix, ...
          windWidthPix, windHeightPix]);
%         obj.pixPerMM = obj.windRectPix(3) / widthMM;
%         [obj.window, obj.windRectPix] = PsychImaging('OpenWindow', obj.screenNumber, obj.grayColor, ...
%           obj.windRectPix, obj.pixelDepth, 2, [], [], kPsychNeed32BPCFloat);
%         obj.topPriorityLevel = MaxPriority(obj.window);
%         [obj.xCenterPix, obj.yCenterPix] = RectCenter(obj.windRectPix);
%         obj.frameDurS = Screen('GetFlipInterval', obj.window);
        set(obj.hFig, 'menubar', 'none', 'toolbar', 'none', 'NumberTitle', 'off', 'resize', 'off');
        set(obj.hFig, 'color', [0.5, 0.5, 0.5]);
        set(obj.hFig, 'Name', 'NSCI 20100 Saccadic Metrics', 'NumberTitle', 'Off');
        axis off;
        obj.hAxes = axes('Parent', obj.hFig, 'units', 'pixels', 'visible', 'off');
        obj.pixPerMM = java.awt.Toolkit.getDefaultToolkit().getScreenResolution() / MetricsConstants.mmPerInch;
        setViewDistanceCM(obj, app);
        drawDot(obj);
      else
        obj.windRectPix = [0, 0, 2000, 100];
        obj.pixPerMM = 3;
      end
    end
    
    %%
    function centerStimulus(obj)
      obj.currentOffsetPix = 0;
      drawDot(obj);
    end
    
    %%
    function pix = degToPix(obj, deg)
      assert(obj.viewDistanceMM > 0, 'Metrics degToPix: viewDistanceMM has not yet been set');
      pix = round(tan(deg / MetricsConstants.degPerRadian) * obj.viewDistanceMM * obj.pixPerMM);
    end   
    
    %% delete the window
    function delete(obj)
      close(obj.hFig);
    end
   
%     function cleanup(~)
%       sca;
%     end
        
    function clearScreen(obj)
      if obj.doStimDisplay
%         Screen('Flip', obj.window);
      end
    end
    
    %% currentOffsetDeg -- offset of the spot from screen center in degrees
    function offsetDeg = currentOffsetDeg(obj)
      offsetMM = obj.currentOffsetPix / obj.pixPerMM;
      offsetDeg = atan2(offsetMM, obj.viewDistanceMM) * 57.2958;
    end
    
  	%%
    function drawCenterStimulus(obj)
      obj.currentOffsetIndex = ceil(obj.numPos / 2);
      drawImage(obj, MetricsConstants.kLeftStim);
    end

    %% drawDot -- draw the dot at the currently specified pixel offset
    function drawDot(obj)
      if obj.doStimDisplay
%         Screen('BlendFunction', obj.window, 'GL_SRC_ALPHA', 'GL_ONE_MINUS_SRC_ALPHA');
%         Screen('DrawDots', obj.window, [obj.currentOffsetPix; 0], 16 , obj.whiteColor, ...
%           [obj.xCenterPix obj.yCenterPix], 1);
%         Screen('Flip', obj.window);
      end
    end
    
     %% drawImage -- draw the dot at the currently specified pixel offset
    function drawImage(obj, imageIndex)
      obj.hAxes.Position(1) = obj.imagePosPix(obj.currentOffsetIndex);
      imshow(obj.dotImage, [0.5, 0.5, 0.5; 1.0, 1.0, 1.0], 'parent', obj.hAxes);
      drawnow;
      obj.currentImageIndex = imageIndex;
    end
    
    %% maxDeg -- maximum extent of the display in degrees (left edge to right edge)
    function limitDeg = maxDeg(obj)
      limitDeg = atan2((obj.windRectPix(3) / 2.0 - obj.marginPix) / obj.pixPerMM, obj.viewDistanceMM) * 57.2958;
    end
    
    %% maxViewDistance -- the largest viewing distance that keeps all the stimuli on the screen
    function limitDistCM = maxViewDistanceCM(obj, maxDeg)
      limitDistCM = (obj.windRectPix(3) / 2.0 - obj.marginPix) / obj.pixPerMM / tan(maxDeg / 57.2958) / 10.0;
    end
    
   %% makeImages.  Each image has the height and width of a spot
    function makeImages(obj)
      % make a circleImage
      diameterPix = floor(obj.spotRadiusPix) * 2;
      circlePix = 1:diameterPix;
      [imgCols, imgRows] = meshgrid(circlePix);
      circlePixels = (imgRows - obj.spotRadiusPix).^2 + (imgCols - obj.spotRadiusPix).^2 <= obj.spotRadiusPix^2;
      [obj.dotImage, ~] = gray2ind(circlePixels, 2);         % make an image from the circle matrix
      [obj.blankImage, ~] = gray2ind(zeros(obj.spotRadiusPix, obj.spotRadiusPix), 1);
      % make the background rectangle
      obj.stepSizePix  = degToPix(obj, obj.stepSizeDeg);
      obj.hAxes.Position(2) = (obj.windRectPix(4) - diameterPix) / 2;
      obj.hAxes.Position(3) = diameterPix;
      obj.hAxes.Position(4) = diameterPix;
      
%       imageSet = zeros(1, diameterPix, diameterPix, 'uint8');   % images are height/width of circle
%       leftCenterPix = floor(0.5 * obj.stepSizePix);   % image is 2 * stepSizePix - circles are at 0.5 and 1.5 stepSizePix
%       rightCenterPix = floor(1.5 * obj.stepSizePix);
%       heightCenterPix = floor(diameterPix / 2);
%       pRange = circlePix - obj.spotRadiusPix;
%       for i = MetricsConstants.kBlankStim:MetricsConstants.kBothStim      % four images, one for each possible mix of dot/no-dot
%         if i == MetricsConstants.kRightStim || i == MetricsConstants.kBothStim       	% needs a right hand dot
%           imageSet(i, heightCenterPix + pRange, rightCenterPix + pRange) = obj.dotImage(circlePix, circlePix);
%         end
%         if i == MetricsConstants.kLeftStim || i == MetricsConstants.kBothStim        	% needs a left hand dot
%           imageSet(i, heightCenterPix + pRange, leftCenterPix + pRange) = obj.dotImage(circlePix, circlePix);
%         end
%         obj.images{i} = squeeze(imageSet(i, :, :));             % save the image in a cell array
%       end
%       obj.images{MetricsConstants.kTestStim} = ones(obj.windRectPix(4), obj.stepSizePix, 'uint8'); % test image (white rect)
      % update the image position values.
      obj.numPos = floor(obj.windRectPix(3) / obj.stepSizePix);
      obj.numPos = obj.numPos - (1 - mod(obj.numPos, 2));         % numPos must be odd
      centerIndex = ceil(obj.numPos / 2);                         % index for the center position
      obj.imagePosPix = zeros(1, obj.numPos);
      obj.imagePosPix(centerIndex) = floor(obj.windRectPix(3) / 2 - 0.5 * obj.stepSizePix);
      for p = 1:floor(obj.numPos / 2)
        obj.imagePosPix(centerIndex - p) = obj.imagePosPix(centerIndex - p + 1) - obj.stepSizePix;
        obj.imagePosPix(centerIndex + p) = obj.imagePosPix(centerIndex + p - 1) + obj.stepSizePix;
      end
    end
    
    %% prepareImages -- set up the images that will be needed for the upcoming trial
    function prepareImages(obj, trialType, stepDirection)
      % first offset the image position if the current position won't accommodate the left or right step.
      % we don't need to do anything for a centering trial because that will be a different image location
      if trialType == MetricsConstants.kCenteringTrial
        drawImage(obj, obj.currentImageIndex);                          % draw for trial equivalence
        obj.gapStim = MetricsConstants.kLeftStim;
        obj.finalStim = obj.gapStim;
      else
        if stepDirection == MetricsConstants.kLeft                           % going to step left
          if obj.currentImageIndex == MetricsConstants.kLeftStim
            obj.currentOffsetIndex = obj.currentOffsetIndex - 1;	% shift one position leftward
          end
          drawImage(obj, MetricsConstants.kRightStim);                  	% draw same spot with new image
          obj.finalStim = MetricsConstants.kLeftStim;
        else
          if obj.currentImageIndex == MetricsConstants.kRightStim          % going to step right
            obj.currentOffsetIndex = obj.currentOffsetIndex + 1; % shift one position leftward
          end
          drawImage(obj, MetricsConstants.kLeftStim);
          obj.finalStim = MetricsConstants.kRightStim;
        end
        % set up the gap stimuli
        switch trialType
          case MetricsConstants.kStepTrial
            obj.gapStim = obj.finalStim;
          case MetricsConstants.kGapTrial
            obj.gapStim = MetricsConstants.kBlankStim;
          case MetricsConstants.kOverlapTrial
            obj.gapStim = MetricsConstants.kBothStim;
        end
      end
    end
    
    %% stepOutOfRange -- Report whether a step would move the target offscreen
    function outOfRange = stepOutOfRange(obj, offsetDeg)
      outOfRange = abs(currentOffsetDeg(obj) + offsetDeg) > maxDeg(obj);
    end
    
    %% positionWindow -- put the window back to where it belongs if it has been moved
    function positionWindow(obj)
      t = get(obj.hFig, 'Position');
      if t(1) ~= obj.marginPix || t(2) ~= obj.marginPix
        set(obj.hFig, 'Position', obj.windRectPix);
      end
    end
    
    %% setViewDistanceCM -- set the viewing distance
    function setViewDistanceCM(obj, app)
      newViewMM = str2double(app.viewDistanceText.Value) / 10.0;
      if isempty(obj.viewDistanceMM) || obj.viewDistanceMM ~= newViewMM
        obj.viewDistanceMM = newViewMM;
        makeImages(obj);                                            % make new spot images
        obj.currentOffsetIndex = ceil(obj.numPos / 2);            	% select center position
        drawImage(obj, MetricsConstants.kLeftStim);                 % draw the center spot
      end
    end
    
    %% stepStimulus -- Step the stimulus
    
    %         function stepSign = stepStimulus(obj, offsetDeg)
    function stepStimulus(obj, offsetDeg)
      %             stepSign = -sign(obj.currentOffsetPix);
      %             if stepSign == 0
      %                 stepSign = sign(rand - 0.5);
      %             end
      %             newOffsetDeg = currentOffsetDeg + stepSign  * offsetDeg;
      newOffsetDeg = currentOffsetDeg(obj) + offsetDeg;
      newOffsetMM = obj.viewDistanceMM * tan(newOffsetDeg / 57.2958);
      obj.currentOffsetPix = newOffsetMM * obj.pixPerMM;
      drawDot(obj);
    end
  end
end
