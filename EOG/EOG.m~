function varargout = EOG(varargin)
% EOG displays an analog data stream from a LabJack U3
%
% EOG signals come through analog input channels 0 and 1 (AIN0 AIN1) on the LabJack. Connect LabJack DAC0/1 to AIN0/1
% for debugging with synthetic eye movements.
%
% Derived from LJSteam.m by 
% M.A. Hopcroft
% mhopeng@gmail.com
%

% Begin initialization code
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @openEOG, ...
                   'gui_OutputFcn',  @initEOG, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end
if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
% End initialization code
end

%% clearButton_Callback
function clearButton_Callback(hObject, eventdata, handles)                  %#ok<DEFNU>

originalSize = get(0, 'DefaultUIControlFontSize');
set(0, 'DefaultUIControlFontSize', 14);
selection = questdlg('Really clear all data? (This cannot be undone).', 'Clear Data', 'Yes', 'No', 'Yes');
set(0, 'DefaultUIControlFontSize', originalSize);
switch selection
    case 'Yes'
    clearAll(handles.saccades);
    clearAll(handles.ampDur);
    taskData = handles.taskData;
    for i = 1:taskData.numOffsets
        clearAll(handles.rtDists{i});
    end
    taskData.offsetsDone = zeros (1, taskData.numOffsets);
    taskData.blocksDone = 0;
    taskData.numSummed = zeros(1, taskData.numOffsets);
    taskData.rawData = zeros(taskData.trialSamples, handles.lbj.numChannels);    % raw data
    taskData.posTrace = zeros(taskData.trialSamples, 1);                         % trial EOG position trace
    taskData.posSummed = zeros(taskData.saccadeSamples, taskData.numOffsets);    % summed position traces
    taskData.posAvg = zeros(taskData.saccadeSamples, taskData.numOffsets);       % averaged position traces
    taskData.velTrace = zeros(taskData.trialSamples, 1);                         % trial EOG velocity trace
    taskData.velSummed = zeros(taskData.saccadeSamples, taskData.numOffsets);    % summed position traces
    taskData.velAvg = zeros(taskData.saccadeSamples, taskData.numOffsets);       % averaged position traces
    taskData.saccDur = zeros(1, taskData.numOffsets);                            % average saccade duration
    handles.taskData = taskData;                                             % pass to LabJack object
    EOGPlots(handles.lbj, taskData, [handles.axes1 handles.axes2 handles.axes3 handles.axes4], 0, 0, handles.saccades);
    guidata(hObject, handles);
end

%% closeEOG: clean up
function closeEOG(hObject, eventdata, handles)
% this function is called  when the user closes the main window
% close the timer and clear the LabJack handle
%
fprintf(1,'EOG: close window\n');
cleanup(handles.visStim);
delete(handles.visStim);
try delete(handles.ampDur); catch, end;
try stop(timerfind); catch, end
try delete(timerfind); catch, end
try clear('handles.lbj'); catch, end
delete(hObject);                                                            % close the program window

%% collectData: function to collect data from LabJack
function collectData(obj, event)                                            %#ok<*INUSD>
% reads stream data from the LabJack

taskData = obj.UserData;
display(sprintf('collect: %d', taskData.counter));
taskData.counter = taskData.counter + 1;
return;

handles = obj.UserData;
lbj = handles.lbj;                                                     % obj.UserData is pointer to handles
[dRaw, errorCode] = getStreamData(lbj);                                     %#ok<*NASGU> % get stream data
taskData = handles.taskData;                                               % get taskData
switch taskData.dataState
    case DataState.dataIdle
         disp('dataIdle');
        return;
    case DataState.dataStart
         disp('dataStart');
       taskData.samplesRead = 0;
        taskData.dataState = DataState.dataCollect;
    case DataState.dataCollect
        disp('dataCollect');
        numNew = min(length(dRaw), taskData.trialSamples - taskData.samplesRead);
        taskData.rawData(taskData.samplesRead + 1:taskData.samplesRead + numNew, :) = dRaw(1:numNew, :);
        taskData.samplesRead = taskData.samplesRead + numNew;
        if (taskData.samplesRead == taskData.trialSamples)
            taskData.dataState = DataState.dataIdle;
            taskData.taskState = TaskState.taskEndtrial;
        end
%    case DataState.dataStop
end
handles.taskData = taskData;                                                    % save new points to handles
obj.UserData = handles;                                                     % save handles

%% initEOG: initialization
function varargout = initEOG(hObject, eventdata, handles)               %#ok<*INUSL>
% initialize application.  We need to set up GUI items  after the GUI has been
% created by after openEOG function. This method gets called after the GUI is
% created but before control returns to the command line.
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
varargout{1} = handles.output;
set(handles.startButton, 'String', 'Start','BackgroundColor', 'green');

% openEOG: just before gui is made visible.
function openEOG(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to EOG (see VARARGIN)

handles.data = EOGTaskData;
taskData.data.counter = 123;

handles.output = hObject;                                               % select default command line output
handles.visStim = EOGStimulus;
handles.saccades = EOGSaccades;
set(hObject, 'CloseRequestFcn', {@closeEOG, handles});                  % close function will close LabJack
handles.lbj = setupLabJack();
    
taskData.offsetsDeg = [4 8 12 16];
taskData.numOffsets = length(taskData.offsetsDeg);
taskData.stepSign = 1;
taskData.offsetIndex = 1;
taskData.offsetsDone = zeros (1, taskData.numOffsets);
taskData.blocksDone = 0;
taskData.sampleRateHz = handles.lbj.SampleRateHz;
taskData.saccadeDurS = 0.25;
taskData.saccadeSamples = floor(taskData.saccadeDurS * taskData.sampleRateHz);
taskData.trialDurS = max(0.50, 2 * taskData.saccadeDurS);
taskData.trialSamples = floor(taskData.trialDurS * taskData.sampleRateHz);
taskData.prestimDurS = min(taskData.trialDurS / 4, 0.250);
taskData.taskState = TaskState.taskIdle;
taskData.trialStartTimeS = 0;
taskData.samplesRead = 0;
taskData.dataState = DataState.dataIdle;
taskData.numSummed = zeros(1, taskData.numOffsets);
taskData.rawData = zeros(taskData.trialSamples, handles.lbj.numChannels);    % raw data
taskData.posTrace = zeros(taskData.trialSamples, 1);                         % trial EOG position trace
taskData.posSummed = zeros(taskData.saccadeSamples, taskData.numOffsets);    % summed position traces
taskData.posAvg = zeros(taskData.saccadeSamples, taskData.numOffsets);       % averaged position traces
taskData.velTrace = zeros(taskData.trialSamples, 1);                         % trial EOG velocity trace
taskData.velSummed = zeros(taskData.saccadeSamples, taskData.numOffsets);    % summed position traces
taskData.velAvg = zeros(taskData.saccadeSamples, taskData.numOffsets);       % averaged position traces

handles.ampDur = EOGAmpDur(handles.axes5, taskData.offsetsDeg);
axes = [handles.axes6 handles.axes7 handles.axes8 handles.axes9];
handles.RTDist = cell(1, taskData.numOffsets);
for i = 1:length(axes)
    handles.rtDists{i} = EOGRTDist(i, taskData.offsetsDeg(i), axes(i));
end
handles.taskData = taskData;                                                 % save in handles
movegui(hObject, 'northeast');
guidata(hObject, handles);                                                   % save the selection

% --- Respond to button press in saveButton.
function saveButton_Callback(hObject, eventdata, handles)
% hObject    handle to saveButton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
    [fileName, filePath] = uiputfile('*.pdf', 'Save Window Plots as PDF', '~/EOGData.pdf');
    if fileName ~= 0
        figurePos = get(handles.figure1, 'position');
        widthInch = figurePos(3) / 72;
        heightInch = figurePos(4) / 72;
        set(handles.figure1, 'PaperOrientation', 'landscape');
        set(handles.figure1, 'PaperUnits', 'inches');
        set(handles.figure1, 'PaperSize', [heightInch + 2, widthInch + 2]);
        set(handles.figure1, 'PaperPosition', [1, 5.5, widthInch, heightInch]);
        print(handles.figure1, '-dpdf', '-r600', '-noui', [filePath fileName]);
    end

%% Set up the LabJack
function lbj = setupLabJack()
%  get hardware info and do not continue if daq device/drivers unavailable
% if isempty(handles.lbj)
    lbj = labJackU6;                        % create the daq object
    open(lbj);                              % open connection to the daq
    if isempty(lbj.handle)
        error('No USB connection to a LabJack was found. Check connections and try again.');
    else
        fprintf(1,'EOG: LabJack Ready.\n\n');
    end
    % create input channel list
    removeChannel(lbj, -1);                     % remove all input channels
    addChannel(lbj, [0 1], [10 10], ['s' 's']); % add channels 0,1 as inputs
    lbj.SampleRateHz = 1000;                    % sample rate (Hz)
    lbj.ResolutionADC = 1;                      % ADC resolution (AD bit depth)
    voltage = 2.5; 
    analogOut(lbj, 0, voltage);                 % For debugging (AOuts to AIns)
    analogOut(lbj, 1, voltage);

    % configure LabJack for analog input streaming

    errorCode = streamConfigure(lbj);
    if errorCode > 0
        fprintf(1,'EOG: Unable to configure LabJack. Error %d.\n',errorCode);
        return
    end

%% respond to button presses
function startButton_Callback(hObject, eventdata, handles)                  %#ok<DEFNU>
% hObject    handle to startButton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

if strcmp(get(handles.startButton, 'String'), 'Start') % if start button, do the following
    fprintf(1,'\nEOG v1.0\n %s\n', datestr(clock));
    setViewDistanceCM(handles.visStim, str2double(get(handles.viewDistanceText, 'string')));
    handles.saccades.thresholdDPS = str2double(get(handles.thresholdDPSText, 'string'));
    handles.saccades.filterWidthMS = str2double(get(handles.filterWidthText, 'string'));
    % create timer to control the task
%     taskTimer = timer('Name', 'TaskTimer', 'ExecutionMode', 'fixedRate',...
%         'Period', 0.1, 'UserData', handles, 'ErrorFcn', {@timerErrorFcnStop, handles}, 'TimerFcn',...
%         {@taskController, handles.visStim, handles.saccades, handles.ampDur, handles.rtDists...
%         [handles.axes1 handles.axes2 handles.axes3 handles.axes4]});
%     
%     % create timer to get data from LabJack
%     dataCollectRateHz = 50;                       % Fast enough to prevent overflow w/o blocking other activity
%     dataTimer = timer('Name', 'LabJackData', 'ExecutionMode', 'fixedRate',...
%         'Period', 1/dataCollectRateHz, 'UserData', handles, 'ErrorFcn', {@timerErrorFcnStop, handles},...
%         'TimerFcn', {@collectData}, 'StartDelay', 0.1); % StartDelay allows other parts of the gui to execute

    taskData = handles.taskData

    taskTimer = timer('Name', 'TaskTimer', 'ExecutionMode', 'fixedRate',...
        'Period', 0.1, 'UserData', taskData.data, 'ErrorFcn', {@timerErrorFcnStop, handles}, 'TimerFcn',...
        {@taskController, handles.visStim, handles.saccades, handles.ampDur, handles.rtDists...
        [handles.axes1 handles.axes2 handles.axes3 handles.axes4]});
    
    % create timer to get data from LabJack
    dataCollectRateHz = 50;                       % Fast enough to prevent overflow w/o blocking other activity
    dataTimer = timer('Name', 'LabJackData', 'ExecutionMode', 'fixedRate',...
        'Period', 1/dataCollectRateHz, 'UserData', taskData.data, 'ErrorFcn', {@timerErrorFcnStop, handles},...
        'TimerFcn', {@collectData}, 'StartDelay', 0.1); % StartDelay allows other parts of the gui to execute

    % set the gui button to "running" state
    set(handles.startButton, 'String', 'Stop', 'BackgroundColor', 'red');
    set(handles.clearButton,'enable','off');
    set(handles.saveButton,'enable','off');
    set(handles.filterWidthText,'enable','off');
    set(handles.viewDistanceText,'enable','off');
    set(handles.thresholdDPSText,'enable','off');
    % save timers to handles and update the GUI display
    handles.taskTimer = taskTimer;
    handles.dataTimer = dataTimer;
    guidata(hObject, handles);    
    
    %% Start plots, data pickup, and data acquisition 
	startStream(handles.lbj);
    start(dataTimer);    
    start(taskTimer);

%% Stop -- we're already running, so it's a the stop button    
else % stop
    stop(timerfind);                                                        % stop/delete timers; pause data stream
    delete(timerfind);        
    stopStream(handles.lbj);
    set(handles.startButton, 'string', 'Start','backgroundColor', 'green');
    set(handles.clearButton,'enable','on');
    set(handles.saveButton,'enable','on');
    set(handles.filterWidthText,'enable','on');
    set(handles.viewDistanceText,'enable','on');
    set(handles.thresholdDPSText,'enable','on');
    centerStimulus(handles.visStim);                                        % recenter fixspot
    drawnow;
end

%% taskController: function to collect data from LabJack
function taskController(obj, events, visStim, saccades, ampDur, rtDists, daqaxes)

taskData = obj.UserData;
display(sprintf('task: %d', taskData.counter));
taskData.counter = taskData.counter + 1;
return;

handles = obj.UserData;
lbj = handles.lbj;                                                              % get handle to LabJack
taskData = handles.taskData;                                                    % taskData is UserData of LabJack
switch taskData.taskState
    case TaskState.taskIdle
        disp('idleTask');
        if taskData.trialStartTimeS == 0                                    % initialize a new trial
            if sum(taskData.offsetsDone) >= taskData.numOffsets             % finished another block
                taskData.offsetsDone = zeros(1, taskData.numOffsets);       % clear counters
                taskData.blocksDone = taskData.blocksDone + 1;              % increment block counter
            end
            taskData.offsetIndex = ceil(rand() * taskData.numOffsets);
            while taskData.offsetsDone(taskData.offsetIndex) > 0
                taskData.offsetIndex = mod(taskData.offsetIndex, taskData.numOffsets) + 1;
            end
            taskData.trialStartTimeS = clock;
            taskData.voltage = visStim.currentOffsetPix / 1000.0;          % debugging- connect DOC0 to AIN Ch0
            analogOut(lbj, 0, 2.5 + taskData.voltage);
            analogOut(lbj, 1, 2.5 - taskData.voltage);
        elseif etime(clock, taskData.trialStartTimeS) > 0.050               % data settled for one taskTimer cycle
        disp('startStim');
            taskData.trialStartTimeS = clock;                               % reset the trial clock
            taskData.stimTimeS = taskData.prestimDurS + rand() * 0.1250;
            taskData.dataState = DataState.dataStart;
            disp(' setting dataState');
            taskData.taskState = TaskState.taskPrestim;
        end
    case TaskState.taskPrestim
        disp('preStim');
        if etime(clock, taskData.trialStartTimeS) > taskData.stimTimeS
            taskData.stepSign = stepStimulus(visStim, taskData.offsetsDeg(taskData.offsetIndex));
            taskData.voltage = visStim.currentOffsetPix / 1000.0;          % debugging- connect DOC0 to AIN Ch0
            analogOut(lbj, 0, 2.5 + taskData.voltage);
            analogOut(lbj, 1, 2.5 - taskData.voltage);
            taskData.taskState = TaskState.taskPoststim;
        end
    case TaskState.taskPoststim
         disp('postStim');
       % just wait for end of trial
    case TaskState.taskEndtrial
        [taskData, startIndex, endIndex] = processSignals(saccades, taskData);
        
        
        
        
        disp('endTrial');
        
        
        
        
        EOGPlots(lbj, taskData, daqaxes, startIndex, endIndex, saccades);
        addAmpDur(ampDur, taskData.offsetIndex, startIndex, endIndex, taskData.sampleRateHz);
        plotAmpDur(ampDur);
        addRT(rtDists{taskData.offsetIndex}, rand() * 100 * taskData.offsetIndex);
        needsRescale = plot(rtDists{taskData.offsetIndex});
        if needsRescale > 0
             for i = 1:taskData.numOffsets
                 rescale(rtDists{i}, needsRescale);
                 plot(rtDists{i});
            end
        end
        taskData.trialStartTimeS = 0;
        taskData.taskState = TaskState.taskIdle;
end
handles.taskData = taskData;
obj.UserData = handles;                                                    % save new points to handles
